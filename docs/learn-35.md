##### 书籍
https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/01.pdf

#### 操作系统学习笔记
学习方法：首先听课，做笔记，阅读笔记，巩固知识，实践

##### 1.程序运行时发生了什么？
```
一个程序运行时在做什么？执行指令。cpu从内存get到一条指令，对其解码然后执行它，比如说两个数相加。完成指令后执行下一条，依此类推，直到程序完成。
```

问题：如何将硬件资源虚拟化？
```
通过操作系统实现，操作系统（也可称之为虚拟机）提供API，利用虚拟机的功能（如访问文件、内存、计算），让用户可以通过软件的形式告诉操作系统做什么。操作系统api称之为系统调用（system call），让应用程序调用。由于操作系统提供了这些调用来运行程序，访问内存、文件等资源，有时也会称操作系统提供了标准库(standard library)。
```
##### 2.虚拟化CPU
虚拟化CPU有什么好处？
```
运行多个程序在一个单核cpu机器上，看起来有多个程序`同时`运行。实际上，cpu是在几个程序间不断地切换运行。

可以通过接口的形式去暂停程序或查看程序。
```
##### 3.虚拟化内存
物理内存的模式本质上是一个存满字节的数组。读内存就是读取某个位置上的地址，再读取地址上的值。

再来说说程序运行发生了什么？
```
程序运行时，代码数据以某种数据结构被加载到内存，通过指令操作内存上的数据。
```

场景：当1套代码同时运行2个程序，程序运行的代码逻辑是：分配1个内存，打印其内存地址。结果两个程序打印出来的内存地址是一样的，那么它们是互相覆盖吗？

不会，因为看到的内存地址是虚拟内存地址，映射到实际的物理内存地址是两个不同的地方。

实际上，不同的程序是用到的资源是隔离、互不影响的。

##### 4. 并发
同一个主程序有两个线程在操纵同一个内存，会发生什么事？

##### 5.持久性
内存在断电或系统崩溃的时候会丢失数据。持久化数据，通过软件系统和硬件磁盘IO来实现。

软件系统称之为文件系统(file system)。

如何实现持久化数据到文件？
- 调用open()创建和打开文件
- write()写入文件
- close()关闭文件

注意：为防止写时系统崩溃或高效写入，文件系统有写时复制、写入特定数据结构(简单列表或复杂B树)。

##### 6.操作系统的发展历史
- 早期：只有一些库，操作人员排列任务进行批处理。
- 为了安全性，如防止一些文件被访问，增加系统调用的概念，通过内核接口形式只暴露出特定硬件的能力，让用户态的应用程序只能有特定权限。
- 多程序时代，操作系统不应该同时只跑一个任务

##### 关于虚拟化的对话
虚拟化cpu是抽象出来的概念，比如说有一个桃子，让每个人都看起来像是拥有一个“桃子”而不自知，这便是虚拟化的奥义所在。

##### 7. 抽象：进程
进程是在运行的程序。进程本身不具备生命周期，它只是磁盘上的一堆数据(字节)，是操作系统让程序真正运行起来。

cpu虚拟化的假象是怎么做到的？
```
操作系统通过时分共享技术，允许进程使用一段时间cpu后，切换到另一个进程。操作系统还有不同的算法调度策略，例如哪个进程优先级高，哪个运行时间更长等。
```

进程的组成成分：
```
进程含有内存，内存用于存储代码指令，程序生成的数据也被写入内存，当然，进程也操纵文件系统当它用到文件的时候
```

与进程相关的系统调用：
- create() 创建进程
- destory() 销毁进程
- status() 进程状态

问：操作系统运行进程(程序)的细节？
```
操作系统将代码和静态文件加载到内存中，这个过程需要从磁盘读取字节。程序在运行前会分配运行时栈，用于存放局部变量等。程序运行时，在C语言需要显示分配动态内存堆（heap）用于存放产生的动态数据。

数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。起初堆会很小。随着程序运行，通过 malloc()库 API 请求更多内存，操作系统可能会参与分配更多内存给进程，以满足这些调用。

操作系统还将执行一些初始化任务，如为每个进程打开标准输入、标准输出、错误三个文件描述符（file descriptor）。

做完初始化任务、分配stack内存这一系列任务后，开始启动进程，即运行main()。
```

进程状态
- 运行（running） 进程在使用cpu，意味着cpu在执行指令
- 就绪（ready） 进程准备好了，但由于某种原因，操作系统决定不在此时运行
- 阻塞（blocked）进程执行了某种操作，直到发生某个时间才运行。如写文件到磁盘，它就会被阻塞，其他进程可以使用cpu

##### 一、什么是性能问题？
```
突然有一天，公司开发在夜里打电话给你，“现在有很多用户说系统弹出一个错误，系统繁忙”之类的。
开发同事一看接口返回500，看了后端日志好像没有特别明显的报错信息。

这时，你赶忙上服务器看下nginx日志，好家伙，一看nginx日志发现后发现接口请求过了60s还没有响应。
`top`看一下服务器资源，用户空间的cpu使用率100%，是哪些进程呢？php-fpm。里面发生了什么？我不知道啊？
唉，重启服务能解决90%的问题，那就重启看看吧。果然，重启后用户反馈正常了。害，暂时是没有问题了，那下次再来一次怎么办？...无后续
```

看，cpu100%这类问题就归属性能问题。

##### 研究性能问题需要学习操作系统主要组件原理
CPU性能、内存、磁盘IO性能、网络

衡量性能的指标：
并发（吞吐）、响应快（时延）

##### 二、CPU性能篇

##### 什么是平均负载
看一个例子：`uptime`
```
$ uptime
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```
说明：
- `02:34:03` 当前时间
- `up 2 days, 20:14` 系统从开机后运行的时长
- `1 user` 正在登录的用户数
- `load average: 0.63, 0.83, 0.88` 最近1分钟、5分钟、15分钟的平均负载(Load average)

`平均负载`是指单位时间内，系统处于可运行(Running或ready)和不可中断(blocked)的进程数。结合最近1分钟、5分钟、15分钟的平均负载，我们可以全面了解cpu的使用情况。像了解一天早中晚的气候变化。

Running是指正在使用cpu；Ready是指代码(指令)已经加载到了内存，等cpu来执行指令；

不可中断是指进程在使用cpu，突然需要进行磁盘IO(读写)的长时间操作，先不用cpu，等IO操作完毕再回来使用cpu。

一般而言，平均负载超过cpu核数70%就要检查cpu的使用情况，考虑是否优化。

查看cpu核数
```
grep 'model name' /proc/cpuinfo|wc -l
```

##### 什么是CPU使用率
cpu使用率衡量了单位时间cpu的繁忙程度。

对于I/O密集型进程，平均负载就高，但cpu却不繁忙，也就是cpu使用率不高。

看一个例子：`top`
```
$ top
top - 11:15:27 up 40 days, 51 min,  1 user,  load average: 0.32, 0.27, 0.26
Tasks: 356 total,   1 running, 355 sleeping,   0 stopped,   0 zombie
%Cpu(s):  4.2 us,  5.6 sy,  0.0 ni, 90.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   7777.8 total,    281.6 free,   4394.8 used,   3101.3 buff/cache
MiB Swap:   2048.0 total,    580.2 free,   1467.8 used.   3015.1 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                                                 
3811294 root      20   0   15440   4540   3768 R  20.0   0.1   0:00.03 top                                                                                                                     
    682 avahi     20   0   10524   5696   3120 S   6.7   0.1 110:29.16 avahi-daemon                                                                                                            
   7726 root      20   0  750872  21192   5772 S   6.7   0.3 259:56.50 travel-api  
```
说明：
- `%Cpu(s)` 比如说有4个cpu，%Cpu(s)代表这4个的平均使用率。

  cpu = 用户空间使用率(us) + 内核空间使用率(sy) + 空闲(id)

  `ni` 用户空间通过改变进程优先级占用的cpu百分比

  `wa` 等待io操作占用的cpu百分比

  `hi/si` 硬/软中断进行cpu上下文切换占用的百分比

- `RES` 使用的真实物理内存（KB）
- `%CPU` 一个cpu的使用率，毕竟一个进程只占用一个cpu
- `TIME+` 累计使用cpu时间

附top使用快捷键说明：
- `shift + m` # 按照内存使用率排序，shift m 等价于大写M
- `shift + p` # 按照cpu使用率排序
- `c` # 显示命令全路径
- `F` # 挑选你要选择展示的列，按下空格选中，* 代表会展示的列(列会出现在最后)，按q退出。
    可以展示进程使用哪一个cpu
- 按`1` # 展示每个cpu的使用情况